<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Dart语言基础三：运算符</title>
    <url>/2021/07/31/Dart%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B8%89%EF%BC%9A%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
    <content><![CDATA[<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><p>Dart 和绝大部分编程语言的运算符一样，所以我们可以用熟悉的方式去执行程序代码运算。不过，<strong>Dart 多了几个额外的运算符，用于简化处理变量实例缺失（即 null）的情况。</strong><span id="more"></span></p>
<ul>
<li>?. 运算符：假设 Point 类有 printInfo() 方法，p 是 Point 的一个可能为 null 的实例。那么，p 调用成员方法的安全代码，可以简化为 p?.printInfo() ，表示 p 为 null 的时候跳过，避免抛出异常。</li>
<li>??= 运算符：如果 a 为 null，则给 a 赋值 value，否则跳过。这种用默认值兜底的赋值语句在 Dart 中我们可以用 a ??= value 表示。</li>
<li>?? 运算符：如果 a 不为 null，返回 a 的值，否则返回 b。在 Java 或者 C++ 中，我们需要通过三元表达式 (a != null)? a : b 来实现这种情况。而在 Dart 中，这类代码可以简化为 a ?? b。</li>
</ul>
<p><strong>在 Dart 中，一切都是对象，就连运算符也是对象成员函数的一部分。</strong></p>
<p>对于系统的运算符，一般情况下只支持基本数据类型和标准库中提供的类型。而对于用户自定义的类，如果想支持基本操作，比如比较大小、相加相减等，则需要用户自己来定义关于这个运算符的具体实现。</p>
<p><strong>Dart 提供了类似 C++ 的运算符覆写机制</strong>，使得我们不仅可以覆写方法，还可以覆写或者自定义运算符。</p>
<p>可以看一个 Vector 类中自定义“+”运算符和覆写”==”运算符的例子：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span> </span>&#123;</span><br><span class="line">  <span class="built_in">num</span> x, y;</span><br><span class="line">  Vector(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y);</span><br><span class="line">  <span class="comment">// 自定义相加运算符，实现向量相加</span></span><br><span class="line">  Vector <span class="keyword">operator</span> +(Vector v) =&gt;  Vector(x + v.x, y + v.y);</span><br><span class="line">  <span class="comment">// 覆写相等运算符，判断向量相等</span></span><br><span class="line">  <span class="built_in">bool</span> <span class="keyword">operator</span> == (<span class="built_in">dynamic</span> v) =&gt; x == v.x &amp;&amp; y == v.y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> x = Vector(<span class="number">3</span>, <span class="number">3</span>);</span><br><span class="line"><span class="keyword">final</span> y = Vector(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">final</span> z = Vector(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="built_in">print</span>(x == (y + z)); <span class="comment">//  输出true</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>operator 是 Dart 的关键字，与运算符一起使用，表示一个类成员运算符函数。在理解时，我们应该把 operator 和运算符作为整体，看作是一个成员函数名。</p>
<h3 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h3><p>Dart 支持常用的算术运算符：</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>+</code></td>
<td>加</td>
</tr>
<tr>
<td><code>–</code></td>
<td>减</td>
</tr>
<tr>
<td><code>-*表达式*</code></td>
<td>一元负, 也可以作为反转（反转表达式的符号）</td>
</tr>
<tr>
<td><code>*</code></td>
<td>乘</td>
</tr>
<tr>
<td><code>/</code></td>
<td>除</td>
</tr>
<tr>
<td><code>~/</code></td>
<td>除并取整</td>
</tr>
<tr>
<td><code>%</code></td>
<td>取模</td>
</tr>
</tbody></table>
<p>示例：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="number">2</span> + <span class="number">3</span>);</span><br><span class="line"><span class="built_in">print</span>(<span class="number">2</span> - <span class="number">3</span>);</span><br><span class="line"><span class="built_in">print</span>(<span class="number">2</span> * <span class="number">3</span>);</span><br><span class="line"><span class="built_in">print</span>(<span class="number">5</span> / <span class="number">2</span>); <span class="comment">// 结果是一个浮点数</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">5</span> ~/ <span class="number">2</span>); <span class="comment">// 结果是一个整数</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">5</span> % <span class="number">2</span>); <span class="comment">// 取余</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;5/2 = <span class="subst">$&#123;<span class="number">5</span> ~/ <span class="number">2</span>&#125;</span> r <span class="subst">$&#123;<span class="number">5</span> % <span class="number">2</span>&#125;</span>&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>Dart 还支持自增自减操作。</p>
<table>
<thead>
<tr>
<th>Operator<code>++*var*</code></th>
<th><code>*var* = *var* + 1</code> (表达式的值为 <code>*var* + 1</code>)</th>
</tr>
</thead>
<tbody><tr>
<td><code>*var*++</code></td>
<td><code>*var* = *var* + 1</code> (表达式的值为 <code>*var*</code>)</td>
</tr>
<tr>
<td><code>--*var*</code></td>
<td><code>*var* = *var* – 1</code> (表达式的值为 <code>*var* – 1</code>)</td>
</tr>
<tr>
<td><code>*var*--</code></td>
<td><code>*var* = *var* – 1</code> (表达式的值为 <code>*var*</code>)</td>
</tr>
</tbody></table>
<p>示例：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a, b;</span><br><span class="line"></span><br><span class="line">a = <span class="number">0</span>;</span><br><span class="line">b = ++a; <span class="comment">// 在 b 赋值前将 a 增加 1。</span></span><br><span class="line"><span class="built_in">print</span>(a == b); <span class="comment">// 1 == 1</span></span><br><span class="line"></span><br><span class="line">a = <span class="number">0</span>;</span><br><span class="line">b = a++; <span class="comment">// 在 b 赋值后将 a 增加 1。</span></span><br><span class="line"><span class="built_in">print</span>(a != b); <span class="comment">// 1 != 0</span></span><br><span class="line"></span><br><span class="line">a = <span class="number">0</span>;</span><br><span class="line">b = --a; <span class="comment">// 在 b 赋值前将 a 减少 1。</span></span><br><span class="line"><span class="built_in">print</span>(a == b); <span class="comment">// -1 == -1</span></span><br><span class="line"></span><br><span class="line">a = <span class="number">0</span>;</span><br><span class="line">b = a--; <span class="comment">// 在 b 赋值后将 a 减少 1。</span></span><br><span class="line"><span class="built_in">print</span>(a != b); <span class="comment">// -1 != 0</span></span><br></pre></td></tr></table></figure>

<h3 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h3><p>下表列出了关系运算符及含义：</p>
<table>
<thead>
<tr>
<th>Operator<code>==</code></th>
<th>相等</th>
</tr>
</thead>
<tbody><tr>
<td><code>!=</code></td>
<td>不等</td>
</tr>
<tr>
<td><code>&gt;</code></td>
<td>大于</td>
</tr>
<tr>
<td><code>&lt;</code></td>
<td>小于</td>
</tr>
<tr>
<td><code>&gt;=</code></td>
<td>大于等于</td>
</tr>
<tr>
<td><code>&lt;=</code></td>
<td>小于等于</td>
</tr>
</tbody></table>
<p>要判断两个对象 x 和 y 是否表示相同的事物使用 <code>==</code> 即可。（在极少数情况下，可能需要使用 <a href="https://api.dart.dev/stable/dart-core/identical.html">identical()</a> 函数来确定两个对象是否完全相同。）。下面是 <code>==</code> 运算符的一些规则：</p>
<ol>
<li>假设有变量 <em>x</em> 和 <em>y</em>，且 x 和 y 至少有一个为 null，则当且仅当 x 和 y 均为 null 时 x == y 才会返回 true，否则只有一个为 null 则返回 false。</li>
<li><code>*x*.==(*y*)</code> 将会返回值，这里不管有没有 y，即 y 是可选的。也就是说 <code>==</code> 其实是 x 中的一个方法，并且可以被重写。详情请查阅<a href="https://dart.cn/guides/language/language-tour#overridable-operators">重写运算符</a>。</li>
</ol>
<p>下面的代码给出了每一种关系运算符的示例：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="number">2</span> == <span class="number">2</span>);</span><br><span class="line"><span class="built_in">print</span>(<span class="number">2</span> != <span class="number">3</span>);</span><br><span class="line"><span class="built_in">print</span>(<span class="number">3</span> &gt; <span class="number">2</span>);</span><br><span class="line"><span class="built_in">print</span>(<span class="number">2</span> &lt; <span class="number">3</span>);</span><br><span class="line"><span class="built_in">print</span>(<span class="number">3</span> &gt;= <span class="number">3</span>);</span><br><span class="line"><span class="built_in">print</span>(<span class="number">2</span> &lt;= <span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<h3 id="类型判断运算符"><a href="#类型判断运算符" class="headerlink" title="类型判断运算符"></a>类型判断运算符</h3><p><code>as</code>、<code>is</code>、<code>is!</code> 运算符是在运行时判断对象类型的运算符。</p>
<table>
<thead>
<tr>
<th>Operator<code>as</code></th>
<th>类型转换（也用作指定<a href="https://dart.cn/guides/language/language-tour#specifying-a-library-prefix">类前缀</a>)）</th>
</tr>
</thead>
<tbody><tr>
<td><code>is</code></td>
<td>如果对象是指定类型则返回 true</td>
</tr>
<tr>
<td><code>is!</code></td>
<td>如果对象是指定类型则返回 false</td>
</tr>
</tbody></table>
<p>当且仅当 <code>obj</code> 实现了 <code>T</code> 的接口，<code>obj is T</code> 才是 true。例如 <code>obj is Object</code> 总为 true，因为所有类都是 Object 的子类。</p>
<p>仅当你确定这个对象是该类型的时候，你才可以使用 <code>as</code> 操作符可以把对象转换为特定的类型。例如：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">(emp <span class="keyword">as</span> Person).firstName = <span class="string">&#x27;Bob&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>如果你不确定这个对象类型是不是 <code>T</code>，请在转型前使用 <code>is T</code> 检查类型。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (emp <span class="keyword">is</span> Person) &#123;</span><br><span class="line">  <span class="comment">// 类型检查</span></span><br><span class="line">  emp.firstName = <span class="string">&#x27;Bob&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你可以使用 <code>as</code> 运算符进行缩写：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">(emp <span class="keyword">as</span> Person).firstName = <span class="string">&#x27;Bob&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p> <strong>备忘:</strong></p>
<p>上述两种方式是有区别的：如果 <code>emp</code> 为 null 或者不为 Person 类型，则第一种方式将会抛出异常，而第二种不会。</p>
<h3 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h3><p>可以使用 <code>=</code> 来赋值，同时也可以使用 <code>??=</code> 来为值为 null 的变量赋值。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将 value 赋值给 a (Assign value to a)</span></span><br><span class="line">a = value;</span><br><span class="line"><span class="comment">// 当且仅当 b 为 null 时才赋值</span></span><br><span class="line">b ??= value;</span><br></pre></td></tr></table></figure>

<p>像 <code>+=</code> 这样的赋值运算符将算数运算符和赋值运算符组合在了一起。</p>
<table>
<thead>
<tr>
<th><code>=</code></th>
<th><code>–=</code></th>
<th><code>/=</code></th>
<th><code>%=</code></th>
<th><code>&gt;&gt;=</code></th>
<th><code>^=</code></th>
</tr>
</thead>
<tbody><tr>
<td><code>+=</code></td>
<td><code>*=</code></td>
<td><code>~/=</code></td>
<td><code>&lt;&lt;=</code></td>
<td><code>&amp;=</code></td>
<td>`</td>
</tr>
</tbody></table>
<p>下表解释了符合运算符的原理：</p>
<table>
<thead>
<tr>
<th>场景</th>
<th>复合运算</th>
<th>等效表达式</th>
</tr>
</thead>
<tbody><tr>
<td><strong>假设有运算符 *op*：</strong></td>
<td><code>a *op*= b</code></td>
<td><code>a = a *op* b</code></td>
</tr>
<tr>
<td><strong>示例：</strong></td>
<td><code>a += b</code></td>
<td><code>a = a + b</code></td>
</tr>
</tbody></table>
<p>下面的例子展示了如何使用赋值以及复合赋值运算符：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>; <span class="comment">// 使用 = 赋值 (Assign using =)</span></span><br><span class="line">a *= <span class="number">3</span>; <span class="comment">// 赋值并做乘法运算 Assign and multiply: a = a * 3</span></span><br><span class="line"><span class="built_in">print</span>(a == <span class="number">6</span>);</span><br></pre></td></tr></table></figure>

<h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><p>使用逻辑运算符你可以反转或组合布尔表达式。</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>!*表达式*</code></td>
<td>对表达式结果取反（即将 true 变为 false，false 变为 true）</td>
</tr>
<tr>
<td>`</td>
<td></td>
</tr>
<tr>
<td><code>&amp;&amp;</code></td>
<td>逻辑与</td>
</tr>
</tbody></table>
<p>下面是使用逻辑表达式的示例：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!done &amp;&amp; (col == <span class="number">0</span> || col == <span class="number">3</span>)) &#123;</span><br><span class="line">  <span class="comment">// ...Do something...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="按位和移位运算符"><a href="#按位和移位运算符" class="headerlink" title="按位和移位运算符"></a>按位和移位运算符</h3><p>在 Dart 中，二进制位运算符可以操作二进制的某一位，但仅适用于整数。</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>&amp;</code></td>
<td>按位与</td>
</tr>
<tr>
<td>`</td>
<td>`</td>
</tr>
<tr>
<td><code>^</code></td>
<td>按位异或</td>
</tr>
<tr>
<td><code>~*表达式*</code></td>
<td>按位取反（即将 “0” 变为 “1”，“1” 变为 “0”）</td>
</tr>
<tr>
<td><code>&lt;&lt;</code></td>
<td>位左移</td>
</tr>
<tr>
<td><code>&gt;&gt;</code></td>
<td>位右移</td>
</tr>
</tbody></table>
<p>下面是使用按位和移位运算符的示例：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> value = <span class="number">0x22</span>;</span><br><span class="line"><span class="keyword">final</span> bitmask = <span class="number">0x0f</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>((value &amp; bitmask) == <span class="number">0x02</span>); <span class="comment">// 按位与 (AND)</span></span><br><span class="line"><span class="built_in">print</span>((value &amp; ~bitmask) == <span class="number">0x20</span>); <span class="comment">// 取反后按位与 (AND NOT)</span></span><br><span class="line"><span class="built_in">print</span>((value | bitmask) == <span class="number">0x2f</span>); <span class="comment">// 按位或 (OR)</span></span><br><span class="line"><span class="built_in">print</span>((value ^ bitmask) == <span class="number">0x2d</span>); <span class="comment">// 按位异或 (XOR)</span></span><br><span class="line"><span class="built_in">print</span>((value &lt;&lt; <span class="number">4</span>) == <span class="number">0x220</span>); <span class="comment">// 位左移 (Shift left)</span></span><br><span class="line"><span class="built_in">print</span>((value &gt;&gt; <span class="number">4</span>) == <span class="number">0x02</span>); <span class="comment">// 位右移 (Shift right)</span></span><br></pre></td></tr></table></figure>

<h3 id="条件表达式"><a href="#条件表达式" class="headerlink" title="条件表达式"></a>条件表达式</h3><p>Dart 有两个特殊的运算符可以用来替代 <a href="https://dart.cn/guides/language/language-tour#if-%E5%92%8C-else">if-else</a> 语句：</p>
<ul>
<li><p><code>*condition* ? *expr1* : *expr2*</code></p>
<p>If <em>condition</em> is true, evaluates <em>expr1</em> (and returns its value); otherwise, evaluates and returns the value of <em>expr2</em>.</p>
</li>
</ul>
<p><code>*条件* ? *表达式 1* : *表达式 2*</code> ：如果条件为 true，执行表达式 1并返回执行结果，否则执行表达式 2 并返回执行结果。</p>
<ul>
<li><p><code>*expr1* ?? *expr2*</code></p>
<p>If <em>expr1</em> is non-null, returns its value; otherwise, evaluates and returns the value of <em>expr2</em>.</p>
</li>
</ul>
<p><code>*表达式 1* ?? *表达式 2*</code>：如果表达式 1 为非 null 则返回其值，否则执行表达式 2 并返回其值。</p>
<p>如果赋值是根据布尔表达式则考虑使用 <code>?:</code>。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> visibility = isPublic ? <span class="string">&#x27;public&#x27;</span> : <span class="string">&#x27;private&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>如果赋值是根据判定是否为 null 则考虑使用 <code>??</code>。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="built_in">String</span> playerName(<span class="built_in">String</span> name) =&gt; name ?? <span class="string">&#x27;Guest&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>上述示例还可以写成至少下面两种不同的形式，只是不够简洁：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 相对使用 ?: 运算符来说稍微长了点。(Slightly longer version uses ?: operator).</span></span><br><span class="line"><span class="built_in">String</span> playerName(<span class="built_in">String</span> name) =&gt; name != <span class="keyword">null</span> ? name : <span class="string">&#x27;Guest&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果使用 if-else 则更长。</span></span><br><span class="line"><span class="built_in">String</span> playerName(<span class="built_in">String</span> name) &#123;</span><br><span class="line">  <span class="keyword">if</span> (name != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Guest&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="级联运算符（-）"><a href="#级联运算符（-）" class="headerlink" title="级联运算符（..）"></a>级联运算符（..）</h3><p>级联运算符（<code>..</code>）可以让你在同一个对象上连续调用多个对象的变量或方法。</p>
<p>比如下面的代码：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="built_in">querySelector</span>(<span class="string">&#x27;#confirm&#x27;</span>) <span class="comment">// 获取对象 (Get an object).</span></span><br><span class="line">  ..text = <span class="string">&#x27;Confirm&#x27;</span> <span class="comment">// 使用对象的成员 (Use its members).</span></span><br><span class="line">  ..classes.add(<span class="string">&#x27;important&#x27;</span>)</span><br><span class="line">  ..onClick.listen((e) =&gt; <span class="built_in">window</span>.alert(<span class="string">&#x27;Confirmed!&#x27;</span>));</span><br></pre></td></tr></table></figure>

<p>第一个方法 <code>querySelector</code> 返回了一个 Selector 对象，后面的级联操作符都是调用这个 Selector 对象的成员并忽略每个操作的返回值。</p>
<p>上面的代码相当于：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> button = <span class="built_in">querySelector</span>(<span class="string">&#x27;#confirm&#x27;</span>);</span><br><span class="line">button.text = <span class="string">&#x27;Confirm&#x27;</span>;</span><br><span class="line">button.classes.add(<span class="string">&#x27;important&#x27;</span>);</span><br><span class="line">button.onClick.listen((e) =&gt; <span class="built_in">window</span>.alert(<span class="string">&#x27;Confirmed!&#x27;</span>));</span><br></pre></td></tr></table></figure>

<p>级联运算符可以嵌套，例如：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> addressBook = (AddressBookBuilder()</span><br><span class="line">      ..name = <span class="string">&#x27;jenny&#x27;</span></span><br><span class="line">      ..email = <span class="string">&#x27;jenny@example.com&#x27;</span></span><br><span class="line">      ..phone = (PhoneNumberBuilder()</span><br><span class="line">            ..number = <span class="string">&#x27;415-555-0100&#x27;</span></span><br><span class="line">            ..label = <span class="string">&#x27;home&#x27;</span>)</span><br><span class="line">          .build())</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure>

<p>在返回对象的函数中谨慎使用级联操作符。例如，下面的代码是错误的：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> sb = <span class="built_in">StringBuffer</span>();</span><br><span class="line">sb.write(<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line">  ..write(<span class="string">&#x27;bar&#x27;</span>); <span class="comment">// 出错：void 对象中没有方法 write (Error: method &#x27;write&#x27; isn&#x27;t defined for &#x27;void&#x27;).</span></span><br></pre></td></tr></table></figure>

<p>上述代码中的 <code>sb.write()</code> 方法返回的是 void，返回值为 <code>void</code> 的方法则不能使用级联运算符。</p>
<p> <strong>备忘:</strong></p>
<p>严格来说 <code>..</code> 级联操作并非一个运算符而是 Dart 的特殊语法。</p>
<h3 id="其他运算符"><a href="#其他运算符" class="headerlink" title="其他运算符"></a>其他运算符</h3><p>大多数其它的运算符，已经在其它的示例中使用过：</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>名字</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>()</code></td>
<td>使用方法</td>
<td>代表调用一个方法</td>
</tr>
<tr>
<td><code>[]</code></td>
<td>访问 List</td>
<td>访问 List 中特定位置的元素</td>
</tr>
<tr>
<td><code>.</code></td>
<td>访问成员</td>
<td>成员访问符</td>
</tr>
<tr>
<td><code>?.</code></td>
<td>条件访问成员</td>
<td>与上述成员访问符类似，但是左边的操作对象不能为 null，例如 foo?.bar，如果 foo 为 null 则返回 null ，否则返回 bar</td>
</tr>
</tbody></table>
<p>更多关于 <code>.</code>, <code>?.</code> 和 <code>..</code> 运算符介绍，请参考<a href="https://dart.cn/guides/language/language-tour#classes">类</a>.</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Dart</tag>
      </tags>
  </entry>
  <entry>
    <title>Dart语言基础二：函数</title>
    <url>/2021/07/27/Dart%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%BA%8C%EF%BC%9A%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="Functions"><a href="#Functions" class="headerlink" title="Functions"></a>Functions</h3><p>Dart 是一种真正面向对象的语言，所以即便函数也是对象并且类型为 <a href="https://api.dart.dev/stable/dart-core/Function-class.html">Function</a>，这意味着函数可以被赋值给变量或者作为其它函数的参数。你也可以像调用函数一样调用 Dart 类的实例。<span id="more"></span></p>
<p>下面是定义一个函数的例子：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="built_in">bool</span> isNoble(<span class="built_in">int</span> atomicNumber) &#123;</span><br><span class="line">  <span class="keyword">return</span> _nobleGases[atomicNumber] != <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然高效 Dart 指南建议在<a href="https://dart.cn/guides/language/effective-dart/design#prefer-type-annotating-public-fields-and-top-level-variables-if-the-type-isnt-obvious">公开的 API 上定义返回类型</a>，不过即便不定义，该函数也依然有效：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">isNoble(atomicNumber) &#123;</span><br><span class="line">  <span class="keyword">return</span> _nobleGases[atomicNumber] != <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果函数体内只包含一个表达式，你可以使用简写语法：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="built_in">bool</span> isNoble(<span class="built_in">int</span> atomicNumber) =&gt; _nobleGases[atomicNumber] != <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>

<p>语法 <code>=&gt; *表达式*</code> 是 <code>&#123; return *表达式*; &#125;</code> 的简写， <code>=&gt;</code> 有时也称之为胖箭头语法。</p>
<p> <strong>备忘:</strong></p>
<p>在 =&gt; 与 ; 之间的只能是 <em>表达式</em> 而非 <em>语句</em>。比如你不能将一个 <a href="https://dart.cn/guides/language/language-tour#if-and-else">if语句</a> 放在其中，但是可以放置 <a href="https://dart.cn/guides/language/language-tour#conditional-expressions">条件表达式</a>。</p>
<h3 id="Parameters"><a href="#Parameters" class="headerlink" title="Parameters"></a>Parameters</h3><p>C++ 与 Java 的做法是，提供函数的重载，即提供同名但参数不同的函数。但 Dart 认为重载会导致混乱，因此从设计之初就不支持重载，而是提供了可选命名参数和可选参数。</p>
<p>函数可以有两种形式的参数：<strong>必要参数</strong> 和 <strong>可选参数</strong>。必要参数定义在参数列表前面，可选参数则定义在必要参数后面。可选参数可以是 <strong>命名的</strong> 或 <strong>位置的</strong>。</p>
<p> <strong>备忘:</strong></p>
<p>某些 API，特别是 <a href="https://flutter.cn/">Flutter</a> 控件的构造器，它只使用命名参数，即便参数是强制性的。</p>
<h3 id="已命名的参数"><a href="#已命名的参数" class="headerlink" title="已命名的参数"></a>已命名的参数</h3><p>已命名的参数是可选参数了，除非他们被特别标记为 required。</p>
<p>当你调用函数时，可以使用 <code>*参数名*: *参数值*</code> 的形式来指定命名参数。例如：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">enableFlags(bold: <span class="keyword">true</span>, hidden: <span class="keyword">false</span>);</span><br></pre></td></tr></table></figure>

<p>定义函数时，使用 <code>&#123;*param1*, *param2*, …&#125;</code> 来指定命名参数：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// <span class="markdown">设置 [bold] 和 [hidden] 标识……</span></span></span><br><span class="line"><span class="comment">/// <span class="markdown">Sets the [bold] and [hidden] flags...</span></span></span><br><span class="line"><span class="keyword">void</span> enableFlags(&#123;<span class="built_in">bool</span> bold, <span class="built_in">bool</span> hidden&#125;) &#123;...&#125;</span><br></pre></td></tr></table></figure>

<p>虽然命名参数是可选参数的一种类型，但是你仍然可以使用 <a href="https://pub.flutter-io.cn/documentation/meta/latest/meta/required-constant.html">@required</a> 注解来标识一个命名参数是必须的参数，此时调用者则必须为该参数提供一个值。例如：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Scrollbar(&#123;Key key, <span class="meta">@required</span> Widget child&#125;)</span><br></pre></td></tr></table></figure>

<p>如果调用者想要通过 <code>Scrollbar</code> 的构造函数构造一个 Scrollbar 对象而不提供 <code>child</code> 参数，则会导致编译错误。</p>
<p><a href="https://pub.flutter-io.cn/documentation/meta/latest/meta/required-constant.html">@required</a> 注解定义在 <a href="https://pub.flutter-io.cn/packages/meta">meta</a> package 中，可以直接导入 <code>package:meta/meta.dart</code> 包使用。</p>
<h3 id="可选的位置参数"><a href="#可选的位置参数" class="headerlink" title="可选的位置参数"></a>可选的位置参数</h3><p>使用 <code>[]</code> 将一系列参数包裹起来作为位置参数：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="built_in">String</span> say(<span class="built_in">String</span> from, <span class="built_in">String</span> msg, [<span class="built_in">String</span> device]) &#123;</span><br><span class="line">  <span class="keyword">var</span> result = <span class="string">&#x27;<span class="subst">$from</span> says <span class="subst">$msg</span>&#x27;</span>;</span><br><span class="line">  <span class="keyword">if</span> (device != <span class="keyword">null</span>) &#123;</span><br><span class="line">    result = <span class="string">&#x27;<span class="subst">$result</span> with a <span class="subst">$device</span>&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是不使用可选参数调用上述函数的示例：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(say(<span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;Howdy&#x27;</span>) == <span class="string">&#x27;Bob says Howdy&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>下面是使用可选参数调用上述函数的示例：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(say(<span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;Howdy&#x27;</span>, <span class="string">&#x27;smoke signal&#x27;</span>) ==</span><br><span class="line">    <span class="string">&#x27;Bob says Howdy with a smoke signal&#x27;</span>);</span><br></pre></td></tr></table></figure>



<h3 id="默认参数值"><a href="#默认参数值" class="headerlink" title="默认参数值"></a>默认参数值</h3><p>可以用 <code>=</code> 为函数的命名和位置参数定义默认值，默认值必须为编译时常量，没有指定默认值的情况下默认值为 <code>null</code>。</p>
<p>下面是设置可选参数默认值示例：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// <span class="markdown">设置 [bold] 和 [hidden] 标识……</span></span></span><br><span class="line"><span class="comment">/// <span class="markdown">Sets the [bold] and [hidden] flags ...</span></span></span><br><span class="line"><span class="keyword">void</span> enableFlags(&#123;<span class="built_in">bool</span> bold = <span class="keyword">false</span>, <span class="built_in">bool</span> hidden = <span class="keyword">false</span>&#125;) &#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// bold 的值将为 true；而 hidden 将为 false。</span></span><br><span class="line">enableFlags(bold: <span class="keyword">true</span>);</span><br></pre></td></tr></table></figure>



<p>在老版本的 Dart 代码中会使用冒号（<code>:</code>）而不是 <code>=</code> 来设置命名参数的默认值。原因在于刚开始的时候命名参数只支持 <code>:</code>。不过现在这个支持已经过时，所以建议现在都 **<a href="https://dart.cn/guides/language/effective-dart/usage#do-use--to-separate-a-named-parameter-from-its-default-value">使用 <code>=</code> 来指定默认值</a>**。</p>
<p>下一个示例将向你展示如何为位置参数设置默认值：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="built_in">String</span> say(<span class="built_in">String</span> from, <span class="built_in">String</span> msg,</span><br><span class="line">    [<span class="built_in">String</span> device = <span class="string">&#x27;carrier pigeon&#x27;</span>, <span class="built_in">String</span> mood]) &#123;</span><br><span class="line">  <span class="keyword">var</span> result = <span class="string">&#x27;<span class="subst">$from</span> says <span class="subst">$msg</span>&#x27;</span>;</span><br><span class="line">  <span class="keyword">if</span> (device != <span class="keyword">null</span>) &#123;</span><br><span class="line">    result = <span class="string">&#x27;<span class="subst">$result</span> with a <span class="subst">$device</span>&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (mood != <span class="keyword">null</span>) &#123;</span><br><span class="line">    result = <span class="string">&#x27;<span class="subst">$result</span> (in a <span class="subst">$mood</span> mood)&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(say(<span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;Howdy&#x27;</span>) ==</span><br><span class="line">    <span class="string">&#x27;Bob says Howdy with a carrier pigeon&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>List 或 Map 同样也可以作为默认值。下面的示例定义了一个名为 <code>doStuff()</code> 的函数，并为其名为 <code>list</code> 和 <code>gifts</code> 的参数指定了一个 List 类型的值和 Map 类型的值。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> doStuff(</span><br><span class="line">    &#123;<span class="built_in">List</span>&lt;<span class="built_in">int</span>&gt; list = <span class="keyword">const</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">    <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">String</span>&gt; gifts = <span class="keyword">const</span> &#123;</span><br><span class="line">      <span class="string">&#x27;first&#x27;</span>: <span class="string">&#x27;paper&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;second&#x27;</span>: <span class="string">&#x27;cotton&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;third&#x27;</span>: <span class="string">&#x27;leather&#x27;</span></span><br><span class="line">    &#125;&#125;) &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&#x27;list:  <span class="subst">$list</span>&#x27;</span>);</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&#x27;gifts: <span class="subst">$gifts</span>&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="main-函数"><a href="#main-函数" class="headerlink" title="main() 函数"></a>main() 函数</h3><p>每个 Dart 程序都必须有一个 <code>main()</code> 顶级函数作为程序的入口，<code>main()</code> 函数返回值为 <code>void</code> 并且有一个 <code>List</code> 类型的可选参数。</p>
<p>下面是一个 Web 应用的 <code>main()</code> 函数示例：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="built_in">querySelector</span>(<span class="string">&#x27;#sample_text_id&#x27;</span>)</span><br><span class="line">    ..text = <span class="string">&#x27;Click me!&#x27;</span></span><br><span class="line">    ..onClick.listen(reverseText);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> <strong>备忘:</strong></p>
<p>上述代码中的 <code>..</code> 语法称之为 <a href="https://dart.cn/guides/language/language-tour#cascade-notation-">级联调用</a>。使用级联访问可以在一个对象上执行多个操作。</p>
<p>下面是使用命令行访问带参数的 <code>main()</code> 函数示例：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用命令 dart args.dart 1 test 运行该应用</span></span><br><span class="line"><span class="comment">// Run the app like this: dart args.dart 1 test</span></span><br><span class="line"><span class="keyword">void</span> main(<span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; arguments) &#123;</span><br><span class="line">  <span class="built_in">print</span>(arguments);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">print</span>(arguments.length == <span class="number">2</span>);</span><br><span class="line">  <span class="built_in">print</span>(<span class="built_in">int</span>.parse(arguments[<span class="number">0</span>]) == <span class="number">1</span>);</span><br><span class="line">  <span class="built_in">print</span>(arguments[<span class="number">1</span>] == <span class="string">&#x27;test&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你可以通过使用 <a href="https://pub.flutter-io.cn/packages/args">参数库</a> 来定义和解析命令行参数。</p>
<h3 id="函数作为一级对象"><a href="#函数作为一级对象" class="headerlink" title="函数作为一级对象"></a>函数作为一级对象</h3><p>可以将函数作为参数传递给另一个函数。例如：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> printElement(<span class="built_in">int</span> element) &#123;</span><br><span class="line">  <span class="built_in">print</span>(element);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 printElement 函数作为参数传递。</span></span><br><span class="line">list.forEach(printElement);</span><br></pre></td></tr></table></figure>

<p>你也可以将函数赋值给一个变量，比如：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> loudify = (msg) =&gt; <span class="string">&#x27;!!! <span class="subst">$&#123;msg.toUpperCase()&#125;</span> !!!&#x27;</span>;</span><br><span class="line"><span class="built_in">print</span>(loudify(<span class="string">&#x27;hello&#x27;</span>) == <span class="string">&#x27;!!! HELLO !!!&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h3><p>大多数方法都是有名字的，比如 <code>main()</code> 或 <code>printElement()</code>。你可以创建一个没有名字的方法，称之为 <em>匿名函数</em>，或 <em>Lambda表达式</em> 或 <em>Closure闭包</em>。你可以将匿名方法赋值给一个变量然后使用它，比如将该变量添加到集合或从中删除。</p>
<p>匿名方法看起来与命名方法类似，在括号之间可以定义参数，参数之间用逗号分割。</p>
<p>后面大括号中的内容则为函数体：</p>
<figure class="highlight clojure"><table><tr><td class="code"><pre><span class="line">([[*类型*] *参数*[, …]]) &#123; *函数体*;&#125;<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<p>下面代码定义了只有一个参数 <code>item</code> 且没有参数类型的匿名方法。List 中的每个元素都会调用这个函数，打印元素位置和值的字符串：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> list = [<span class="string">&#x27;apples&#x27;</span>, <span class="string">&#x27;bananas&#x27;</span>, <span class="string">&#x27;oranges&#x27;</span>];</span><br><span class="line">list.forEach((item) &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&#x27;<span class="subst">$&#123;list.indexOf(item)&#125;</span>: <span class="subst">$item</span>&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>如果函数体内只有一行语句，你可以使用胖箭头缩写法。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">list.forEach(</span><br><span class="line">    (item) =&gt; <span class="built_in">print</span>(<span class="string">&#x27;<span class="subst">$&#123;list.indexOf(item)&#125;</span>: <span class="subst">$item</span>&#x27;</span>));</span><br></pre></td></tr></table></figure>

<h3 id="词法作用域"><a href="#词法作用域" class="headerlink" title="词法作用域"></a>词法作用域</h3><p>Dart 是词法有作用域语言，变量的作用域在写代码的时候就确定了，大括号内定义的变量只能在大括号内访问，与 Java 类似。</p>
<p>下面是一个嵌套函数中变量在多个作用域中的示例：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="built_in">bool</span> topLevel = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="keyword">var</span> insideMain = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> myFunction() &#123;</span><br><span class="line">    <span class="keyword">var</span> insideFunction = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> nestedFunction() &#123;</span><br><span class="line">      <span class="keyword">var</span> insideNestedFunction = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">      <span class="built_in">print</span>(topLevel);</span><br><span class="line">      <span class="built_in">print</span>(insideMain);</span><br><span class="line">      <span class="built_in">print</span>(insideFunction);</span><br><span class="line">      <span class="built_in">print</span>(insideNestedFunction);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意 <code>nestedFunction()</code> 函数可以访问包括顶层变量在内的所有的变量。</p>
<h3 id="词法闭包"><a href="#词法闭包" class="headerlink" title="词法闭包"></a>词法闭包</h3><p><em>闭包</em> 即一个函数对象，即使函数对象的调用在它原始作用域之外，依然能够访问在它词法作用域内的变量。</p>
<p>函数可以封闭定义到它作用域内的变量。接下来的示例中，函数 <code>makeAdder()</code> 捕获了变量 <code>addBy</code>。无论函数在什么时候返回，它都可以使用捕获的 <code>addBy</code> 变量。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// <span class="markdown">返回一个将 [addBy] 添加到该函数参数的函数。</span></span></span><br><span class="line"><span class="comment">/// <span class="markdown">Returns a function that adds [addBy] to the</span></span></span><br><span class="line"><span class="comment">/// <span class="markdown">function&#x27;s argument.</span></span></span><br><span class="line"><span class="built_in">Function</span> makeAdder(<span class="built_in">int</span> addBy) &#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="built_in">int</span> i) =&gt; addBy + i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="comment">// 生成加 2 的函数。</span></span><br><span class="line">  <span class="keyword">var</span> add2 = makeAdder(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 生成加 4 的函数。</span></span><br><span class="line">  <span class="keyword">var</span> add4 = makeAdder(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">print</span>(add2(<span class="number">3</span>) == <span class="number">5</span>);</span><br><span class="line">  <span class="built_in">print</span>(add4(<span class="number">3</span>) == <span class="number">7</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="测试函数是否相等"><a href="#测试函数是否相等" class="headerlink" title="测试函数是否相等"></a>测试函数是否相等</h3><p>下面是顶级函数，静态方法和示例方法相等性的测试示例：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> foo() &#123;&#125; <span class="comment">// 定义顶层函数 (A top-level function)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">void</span> bar() &#123;&#125; <span class="comment">// 定义静态方法</span></span><br><span class="line">  <span class="keyword">void</span> baz() &#123;&#125; <span class="comment">// 定义实例方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="keyword">var</span> x;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 比较顶层函数是否相等。</span></span><br><span class="line">  x = foo;</span><br><span class="line">  <span class="built_in">print</span>(foo == x);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 比较静态方法是否相等。</span></span><br><span class="line">  x = A.bar;</span><br><span class="line">  <span class="built_in">print</span>(A.bar == x);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 比较实例方法是否相等。</span></span><br><span class="line">  <span class="keyword">var</span> v = A(); <span class="comment">// A 的实例 #1</span></span><br><span class="line">  <span class="keyword">var</span> w = A(); <span class="comment">// A 的实例 #2</span></span><br><span class="line">  <span class="keyword">var</span> y = w;</span><br><span class="line">  x = w.baz;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这两个闭包引用了相同的实例对象，因此它们相等。</span></span><br><span class="line">  <span class="built_in">print</span>(y.baz == x);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这两个闭包引用了不同的实例对象，因此它们不相等。</span></span><br><span class="line">  <span class="built_in">print</span>(v.baz != w.baz);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Dart</tag>
      </tags>
  </entry>
  <entry>
    <title>Dart语言概览</title>
    <url>/2021/07/15/Dart%E8%AF%AD%E8%A8%80%E6%A6%82%E8%A7%88/</url>
    <content><![CDATA[<h1 id="Dart语言概览"><a href="#Dart语言概览" class="headerlink" title="Dart语言概览"></a>Dart语言概览</h1><h2 id="一、Dart是什么"><a href="#一、Dart是什么" class="headerlink" title="一、Dart是什么"></a>一、Dart是什么</h2><p>2011 年 10 月，在丹麦召开的 GOTO 大会上，Google 发布了一种新的编程语言 Dart。如同 Kotlin 和 Swift 的出现，分别是为了解决 Java 和 Objective-C 在编写应用程序的一些实际问题一样，Dart 的诞生正是要解决 JavaScript 存在的、在语言本质上无法改进的缺陷。<span id="more"></span></p>
<p>JavaScript 之父布兰登 · 艾克（Brendan Eich）曾在一次采访中说，JavaScript“几天就设计出来了”。</p>
<p>由于设计时间太短，一些细节考虑得不够严谨，导致后来很长一段时间，使用 JavaScript 开发的程序混乱不堪。出于对 JavaScript 的不满，Google 的程序员们决定自己写一个新语言来换掉它，所以 Dart 的最初定位也是一种运行在浏览器中的脚本语言。而为了推广 Dart，Google 甚至将自己的 Chrome 浏览器内置了 Dart VM，可以直接高效地运行 Dart 代码。而对于普通浏览器来说，Google 也提供了一套能够将 Dart 代码编译成 JavaScript 代码的转换工具。这样一来，开发者们就可以毫无顾虑地使用 Dart 去开发了，而不必担心兼容问题。再加上出身名门，Dart 在一开始就赢得了部分前端开发者的关注。</p>
<p>但，JavaScript 的生命力似乎比预想的更强大。</p>
<p>JavaScript 因为 Node.js 焕发了第二春，而 Dart 就没有那么好的运气了。由于缺少顶级项目的使用，Dart 始终不温不火。2015 年，在听取了大量开发者的反馈后，Google 决定将内置的 Dart VM 引擎从 Chrome 移除，这对 Dart 的发展来说是重大挫折，替代 JavaScript 就更无从谈起了。</p>
<p>但，Dart 也借此机会开始转型：在 Google 内部孵化了移动开发框架 Flutter，弯道超车进入了移动开发的领域；而在 Google 未来的操作系统 Fuchsia 中，Dart 更是被指定为官方的开发语言。</p>
<p>也正是因为使用者不多、历史包袱少，所以在经历了这么多的故事后，Dart 可以彻底转变思路，成为专注大前端与跨平台生态的语言。</p>
<h2 id="二、Dart的特性"><a href="#二、Dart的特性" class="headerlink" title="二、Dart的特性"></a>二、Dart的特性</h2><h3 id="1-JIT与AOT"><a href="#1-JIT与AOT" class="headerlink" title="1. JIT与AOT"></a>1. JIT与AOT</h3><p>借助于先进的工具链和编译器，Dart 是少数同时支持 JIT（Just In Time，即时编译）和 AOT（Ahead of Time，运行前编译）的语言之一。</p>
<ul>
<li>JIT 在运行时即时编译，在开发周期中使用，可以动态下发和执行代码，开发测试效率高，但运行速度和执行性能则会因为运行时即时编译受到影响。</li>
<li>AOT 即提前编译，可以生成被直接执行的二进制代码，运行速度快、执行性能表现好，但每次执行前都需要提前编译，开发测试效率低。</li>
</ul>
<p> AOT 的典型代表是 C/C++，它们必须在执行前编译成机器码；而 JIT 的代表，则包括了如 JavaScript、Python 等几乎所有的脚本语言。</p>
<h3 id="2-内存分配与垃圾回收"><a href="#2-内存分配与垃圾回收" class="headerlink" title="2. 内存分配与垃圾回收"></a>2. 内存分配与垃圾回收</h3><p>Dart VM 的内存分配策略比较简单，创建对象时只需要在堆上移动指针，内存增长始终是线性的，省去了查找可用内存的过程。</p>
<p>在 Dart 中，并发是通过 Isolate 实现的。Isolate 是类似于线程但不共享内存，独立运行的 worker。这样的机制，就可以让 Dart 实现无锁的快速分配。</p>
<p>Dart 的垃圾回收，则是采用了多生代算法。新生代在回收内存时采用“半空间”机制，触发垃圾回收时，Dart 会将当前半空间中的“活跃”对象拷贝到备用空间，然后整体释放当前空间的所有内存。回收过程中，Dart 只需要操作少量的“活跃”对象，没有引用的大量“死亡”对象则被忽略，这样的回收机制很适合 Flutter 框架中大量 Widget 销毁重建的场景。</p>
<h3 id="3-单线程模式"><a href="#3-单线程模式" class="headerlink" title="3. 单线程模式"></a>3. 单线程模式</h3><p>支持并发执行线程的高级语言（比如，C++、Java、Objective-C），大都以抢占式的方式切换线程，即：每个线程都会被分配一个固定的时间片来执行，超过了时间片后线程上下文将被抢占后切换。如果这时正在更新线程间的共享资源，抢占后就可能导致数据不同步的问题。</p>
<p>解决这一问题的典型方法是，使用锁来保护共享资源，但锁本身又可能会带来性能损耗，甚至出现死锁等更严重的问题。</p>
<p>这时，Dart 是单线程模型的优势就体现出来了，因为它天然不存在资源竞争和状态同步的问题。</p>
<p>这就意味着，一旦某个函数开始执行，就将执行到这个函数结束，而不会被其他 Dart 代码打断。所以，Dart 中并没有线程，只有 Isolate（隔离区）。Isolates 之间不会共享内存，就像几个运行在不同进程中的 worker，通过事件循环（Event Looper）在事件队列（Event Queue）上传递消息通信。</p>
<h3 id="4-无需单独的声明式布局"><a href="#4-无需单独的声明式布局" class="headerlink" title="4.无需单独的声明式布局"></a>4.无需单独的声明式布局</h3><p>在 Flutter 中，界面布局直接通过 Dart 编码来定义。</p>
<p>Dart 声明式编程布局易于阅读和可视化，使得 Flutter 并不需要类似 JSX 或 XML 的声明式布局语言。所有的布局都使用同一种格式，也使得 Flutter 很容易提供高级工具使布局更简单。</p>
<p>开发过程也不需要可视化界面构建器，因为热重载可以让我们立即在手机上看到运行效果。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Dart</tag>
      </tags>
  </entry>
  <entry>
    <title>Dart语言基础一：变量与类型</title>
    <url>/2021/07/15/Dart%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B8%80%EF%BC%9A%E5%8F%98%E9%87%8F%E4%B8%8E%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h3 id="变量定义"><a href="#变量定义" class="headerlink" title="变量定义"></a>变量定义</h3><p>在 Dart 中，我们可以用 var 或者具体的类型来声明一个变量。当使用 var 定义变量时，表示类型是交由编译器推断决定的，当然你也可以用静态类型去定义变量，更清楚地跟编译器表达你的意图，这样编辑器和编译器就能使用这些静态类型，向你提供代码补全或编译警告的提示了。<span id="more"></span></p>
<ul>
<li>var 是一个关键字，意思是”我不关心这里的类型是什么”，系统会自动判断类型 runtimeType;</li>
<li>dynamic：动态任意类型，<strong>编译阶段不检查</strong>类型</li>
<li>Object ：动态任意类型，<strong>编译阶段</strong>检查类型</li>
</ul>
<p>三者区别：var初始化确定类型后不可更改类型，Object以及dynamic可以更改类型。</p>
<p>在默认情况下，未初始化的变量的值都是 null，因此我们不用担心无法判定一个传递过来的、未定义变量到底是 undefined，还是什么而写一堆冗长的判断语句</p>
<h3 id="常量定义"><a href="#常量定义" class="headerlink" title="常量定义"></a>常量定义</h3><p>如果你想定义不可变的变量，则需要在定义变量前加上 final 或 const 关键字：</p>
<ul>
<li>const，表示变量在编译期间即能确定的值；</li>
<li>final 则不太一样，用它定义的变量可以在运行时确定值，而一旦确定后就不可再变。</li>
</ul>
<p>声明 const 常量与 final 常量的典型例子，如下所示：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> name = <span class="string">&#x27;Andy&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> count = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">70</span>;  </span><br><span class="line"><span class="keyword">var</span> y = <span class="number">30</span>;</span><br><span class="line"><span class="keyword">final</span> z = x / y;</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong> 实例变量可以是 <code>final</code> 类型但不能是 <code>const</code> 类型。 必须在构造函数体执行之前初始化 final 实例变量 —— 在变量声明中，参数构造函数中或构造函数的<a href="https://www.dartcn.com/guides/language/language-tour#initializer-list">初始化列表</a>中进行初始化 。</p>
<h2 id="内建类型"><a href="#内建类型" class="headerlink" title="内建类型"></a>内建类型</h2><p>Dart 语言支持以下内建类型：</p>
<ul>
<li>Number</li>
<li>String</li>
<li>Boolean</li>
<li>List (也被称为 <em>Array</em>)</li>
<li>Map</li>
<li>Set</li>
<li>Rune (用于在字符串中表示 Unicode 字符)</li>
<li>Symbol</li>
</ul>
<p>这些类型都可以被初始化为字面量。 例如, <code>&#39;this is a string&#39;</code> 是一个字符串的字面量， <code>true</code> 是一个布尔的字面量。</p>
<p>因为在 Dart 所有的变量终究是一个对象（一个类的实例）， 所以变量可以使用 <em>构造涵数</em> 进行初始化。 一些内建类型拥有自己的构造函数。 例如， 通过 <code>Map()</code> 来构造一个 map 变量。</p>
<h3 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h3><p>Dart 语言的 Number 有两种类型:</p>
<ul>
<li><p><a href="https://api.dartlang.org/stable/dart-core/int-class.html">int</a></p>
<p>整数值不大于64位， 具体取决于平台。 在 Dart VM 上， 值的范围从 -263 到 263 - 1. Dart 被编译为 JavaScript 时，使用 <a href="https://stackoverflow.com/questions/2802957/number-of-bits-in-javascript-numbers/2803010#2803010">JavaScript numbers,</a> 值的范围从 -253 到 253 - 1.</p>
</li>
<li><p><a href="https://api.dartlang.org/stable/dart-core/double-class.html">double</a></p>
<p>64位（双精度）浮点数，依据 IEEE 754 标准。</p>
</li>
</ul>
<p><code>int</code> 和 <code>double</code> 都是 <a href="https://api.dartlang.org/stable/dart-core/num-class.html"><code>num</code>.</a> 的亚类型。 num 类型包括基本运算 +， -， /， 和 *， 以及 <code>abs()</code>，<code> ceil()</code>， 和 <code>floor()</code>， 等函数方法。  <a href="https://api.dartlang.org/stable/dart-math">dart:math</a> 库。</p>
<p>整数类型不包含小数点。 下面是定义整数类型字面量的例子:</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">var x</span> = 1;</span><br><span class="line"><span class="attribute">var hex</span> = 0xDEADBEEF;</span><br></pre></td></tr></table></figure>

<p>如果一个数字包含小数点，那么就是小数类型。 下面是定义小数类型字面量的例子:</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">var</span> y = <span class="number">1</span>.<span class="number">1</span>;</span><br><span class="line"><span class="attribute">var</span> exponents = <span class="number">1</span>.<span class="number">42</span>e<span class="number">5</span>;</span><br></pre></td></tr></table></figure>

<p>从 Dart 2.1 开始，必要的时候 int 字面量会自动转换成 double 类型。</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">double</span> z = <span class="number">1</span>; // 相当于 double z = <span class="number">1</span>.<span class="number">0</span>.</span><br></pre></td></tr></table></figure>

<p><strong>版本提示：</strong> 在 2.1 之前，在 double 上下文中使用 int 字面量是错误的。</p>
<p>以下是将字符串转换为数字的方法，反之亦然：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// String -&gt; int</span></span><br><span class="line"><span class="keyword">var</span> one = <span class="built_in">int</span>.parse(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// String -&gt; double</span></span><br><span class="line"><span class="keyword">var</span> onePointOne = <span class="built_in">double</span>.parse(<span class="string">&#x27;1.1&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// int -&gt; String</span></span><br><span class="line"><span class="built_in">String</span> oneAsString = <span class="number">1.</span>toString();</span><br><span class="line"></span><br><span class="line"><span class="comment">// double -&gt; String</span></span><br><span class="line"><span class="built_in">String</span> piAsString = <span class="number">3.14159</span>.toStringAsFixed(<span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<p>int 特有的传统按位运算操作，移位（&lt;&lt;， &gt;&gt;），按位与（&amp;）以及 按位或（|）。 例如：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">print</span>((<span class="number">3</span> &lt;&lt; <span class="number">1</span>) == <span class="number">6</span>); // <span class="number">0011</span> &lt;&lt; <span class="number">1</span> == <span class="number">0110</span></span><br><span class="line"><span class="attribute">print</span>((<span class="number">3</span> &gt;&gt; <span class="number">1</span>) == <span class="number">1</span>); // <span class="number">0011</span> &gt;&gt; <span class="number">1</span> == <span class="number">0001</span></span><br><span class="line"><span class="attribute">print</span>((<span class="number">3</span> | <span class="number">4</span>) == <span class="number">7</span>); // <span class="number">0011</span> | <span class="number">0100</span> == <span class="number">0111</span></span><br></pre></td></tr></table></figure>

<p>数字类型字面量是编译时常量。 在算术表达式中，只要参与计算的因子是编译时常量， 那么算术表达式的结果也是编译时常量。</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">const msPerSecond</span> = 1000;</span><br><span class="line"><span class="attribute">const secondsUntilRetry</span> = 5;</span><br><span class="line"><span class="attribute">const msUntilRetry</span> = secondsUntilRetry * msPerSecond;</span><br></pre></td></tr></table></figure>

<h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p>Dart 字符串是一组 UTF-16 单元序列。 字符串通过单引号或者双引号创建。</p>
<figure class="highlight cal"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 = <span class="string">&#x27;Single quotes work well for string literals.&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> s2 = <span class="string">&quot;Double quotes work just as well.&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> s3 = <span class="string">&#x27;It\&#x27;</span>s easy <span class="keyword">to</span> escape the string delimiter.<span class="string">&#x27;;</span></span><br><span class="line"><span class="string">var s4 = &quot;It&#x27;</span>s even easier <span class="keyword">to</span> use the other delimiter.<span class="string">&quot;;</span></span><br></pre></td></tr></table></figure>

<p>字符串可以通过 <code>$&#123;</code><em>expression</em><code>&#125;</code> 的方式内嵌表达式。 如果表达式是一个标识符，则 {} 可以省略。 在 Dart 中通过调用就对象的 <code>toString()</code> 方法来得到对象相应的字符串。</p>
<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">var s = <span class="symbol">&#x27;string</span> interpolation&#x27;;</span><br><span class="line"></span><br><span class="line">print(<span class="symbol">&#x27;Dart</span> has $s, which <span class="keyword">is</span> very handy.&#x27; ==</span><br><span class="line">    <span class="symbol">&#x27;Dart</span> has string interpolation, &#x27; +</span><br><span class="line">        <span class="symbol">&#x27;which</span> <span class="keyword">is</span> very handy.&#x27;);</span><br><span class="line">print(<span class="symbol">&#x27;That</span> deserves <span class="keyword">all</span> caps. &#x27; +</span><br><span class="line">        &#x27;$&#123;s.toUpperCase()&#125; <span class="keyword">is</span> very handy!&#x27; ==</span><br><span class="line">    <span class="symbol">&#x27;That</span> deserves <span class="keyword">all</span> caps. &#x27; +</span><br><span class="line">        <span class="symbol">&#x27;STRING</span> INTERPOLATION <span class="keyword">is</span> very handy!&#x27;);</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong> <code>==</code> 运算符用来测试两个对象是否相等。 在字符串中，如果两个字符串包含了相同的编码序列，那么这两个字符串相等。</p>
<p>可以使用 <code>+</code> 运算符来把多个字符串连接为一个，也可以把多个字面量字符串写在一起来实现字符串连接：</p>
<figure class="highlight axapta"><table><tr><td class="code"><pre><span class="line"><span class="built_in">var</span> s1 = <span class="string">&#x27;String &#x27;</span></span><br><span class="line">    <span class="string">&#x27;concatenation&#x27;</span></span><br><span class="line">    <span class="string">&quot; works even over line breaks.&quot;</span>;</span><br><span class="line"><span class="keyword">print</span>(s1 ==</span><br><span class="line">    <span class="string">&#x27;String concatenation works even over &#x27;</span></span><br><span class="line">    <span class="string">&#x27;line breaks.&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">var</span> s2 = <span class="string">&#x27;The + operator &#x27;</span> + <span class="string">&#x27;works, as well.&#x27;</span>;</span><br><span class="line"><span class="keyword">print</span>(s2 == <span class="string">&#x27;The + operator works, as well.&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>使用连续三个单引号或者三个双引号实现多行字符串对象的创建：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">var s1 = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">You can create</span></span><br><span class="line"><span class="string">multi-line strings like this one.</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>;</span><br><span class="line"></span><br><span class="line">var s2 = <span class="string">&quot;&quot;&quot;This is also a</span></span><br><span class="line"><span class="string">multi-line string.&quot;&quot;&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>使用 <code>r</code> 前缀，可以创建 “原始 raw” 字符串：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">var s = <span class="string">r&quot;In a raw string, even \n isn&#x27;t special.&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>参考 <a href="https://www.dartcn.com/guides/language/language-tour#runes">Runes</a> 来了解如何在字符串中表达 Unicode 字符。</p>
<p>一个编译时常量的字面量字符串中，如果存在插值表达式，表达式内容也是编译时常量， 那么该字符串依旧是编译时常量。 插入的常量值类型可以是 null，数值，字符串或布尔值。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// const 类型数据</span></span><br><span class="line"><span class="keyword">const</span> aConstNum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> aConstBool = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">const</span> aConstString = <span class="string">&#x27;a constant string&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非 const 类型数据</span></span><br><span class="line"><span class="keyword">var</span> aNum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> aBool = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">var</span> aString = <span class="string">&#x27;a string&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> aConstList = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> validConstString = <span class="string">&#x27;<span class="subst">$aConstNum</span> <span class="subst">$aConstBool</span> <span class="subst">$aConstString</span>&#x27;</span>; <span class="comment">//const 类型数据</span></span><br><span class="line"><span class="comment">// const invalidConstString = &#x27;$aNum $aBool $aString $aConstList&#x27;; //非 const 类型数据</span></span><br></pre></td></tr></table></figure>

<p>更多关于 string 的使用, 参考 <a href="https://www.dartcn.com/guides/libraries/library-tour#strings-and-regular-expressions">字符串和正则表达式</a>.</p>
<h3 id="Boolean"><a href="#Boolean" class="headerlink" title="Boolean"></a>Boolean</h3><p>Dart 使用 <code>bool</code> 类型表示布尔值。 Dart 只有字面量 <code>true</code> and <code>false</code> 是布尔类型， 这两个对象都是编译时常量。</p>
<p>Dart 的类型安全意味着不能使用 <code>if (*nonbooleanValue*)</code> 或者 <code>print (*nonbooleanValue*)</code>。 而是应该像下面这样，明确的进行值检查：</p>
<figure class="highlight axapta"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 检查空字符串。</span></span><br><span class="line"><span class="built_in">var</span> fullName = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"><span class="keyword">print</span>(fullName.isEmpty);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查 0 值。</span></span><br><span class="line"><span class="built_in">var</span> hitPoints = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">print</span>(hitPoints &lt;= <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查 null 值。</span></span><br><span class="line"><span class="built_in">var</span> unicorn;</span><br><span class="line"><span class="keyword">print</span>(unicorn == <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查 NaN 。</span></span><br><span class="line"><span class="built_in">var</span> iMeantToDoThis = <span class="number">0</span> / <span class="number">0</span>;</span><br><span class="line"><span class="keyword">print</span>(iMeantToDoThis.isNaN);</span><br></pre></td></tr></table></figure>

<h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p>几乎每种编程语言中最常见的集合可能是 <em>array</em> 或有序的对象集合。 在 Dart 中的 <em>Array</em> 就是 <a href="https://api.dartlang.org/stable/dart-core/List-class.html">List</a> 对象， 通常称之为 <em>List</em> 。</p>
<p>Dart 中的 List 字面量非常像 JavaScript 中的 array 字面量。 下面是一个 Dart List 的示例：</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">var list</span> = [1, 2, 3];</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong> Dart 推断 <code>list</code> 的类型为 <code>List&lt;int&gt;</code> 。 如果尝试将非整数对象添加到此 List 中， 则分析器或运行时会引发错误。 有关更多信息，请阅读 <a href="https://www.dartcn.com/guides/language/sound-dart#type-inference">类型推断。</a></p>
<p>Lists 的下标索引从 0 开始，第一个元素的索引是 0。 list.length - 1 是最后一个元素的索引。 访问 List 的长度和元素与 JavaScript 中的用法一样：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">var list = [1, 2, 3];</span><br><span class="line"><span class="builtin-name">print</span>(list.length == 3);</span><br><span class="line"><span class="builtin-name">print</span>(list[1] == 2);</span><br><span class="line"></span><br><span class="line">list[1] = 1;</span><br><span class="line"><span class="builtin-name">print</span>(list[1] == 1);</span><br></pre></td></tr></table></figure>

<p>在 List 字面量之前添加 const 关键字，可以定义 List 类型的编译时常量：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">var constantList = const [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="regexp">//</span> constantList[<span class="number">1</span>] = <span class="number">1</span>; <span class="regexp">//</span> 取消注释会引起错误。</span><br></pre></td></tr></table></figure>

<p>List 类型包含了很多 List 的操作函数。 更多信息参考 <a href="https://www.dartcn.com/guides/language/language-tour#generics">泛型</a> 和 <a href="https://www.dartcn.com/guides/libraries/library-tour#collections">集合</a>.</p>
<h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p>在 Dart 中 Set 是一个元素唯一且无需的集合。 Dart 为 Set 提供了 Set 字面量和 <a href="https://api.dartlang.org/stable/dart-core/Set-class.html">Set</a> 类型。</p>
<p><strong>版本提示：</strong> 虽然 Set <em>类型</em> 一直是 Dart 的核心部分， 但在 Dart2.2 中才引入了 Set <em>字面量</em> 。</p>
<p>下面是通过字面量创建 Set 的一个简单示例：</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">var halogens</span> = &#123;<span class="string">&#x27;fluorine&#x27;</span>, <span class="string">&#x27;chlorine&#x27;</span>, <span class="string">&#x27;bromine&#x27;</span>, <span class="string">&#x27;iodine&#x27;</span>, <span class="string">&#x27;astatine&#x27;</span>&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>Note:</strong> Dart 推断 <code>halogens</code> 类型为 <code>Set&lt;String&gt;</code> 。如果尝试为它添加一个 错误类型的值，分析器或执行时会抛出错误。更多内容，参阅 <a href="https://www.dartcn.com/guides/language/sound-dart#type-inference">类型推断</a>。</p>
<p>要创建一个空集，使用前面带有类型参数的 <code>&#123;&#125;</code> ，或者将 <code>&#123;&#125;</code> 赋值给 <code>Set</code> 类型的变量：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">var names = &lt;String&gt;&#123;&#125;;</span><br><span class="line"><span class="regexp">//</span> Set&lt;String&gt; names = &#123;&#125;; <span class="regexp">//</span> 这样也是可以的。</span><br><span class="line"><span class="regexp">//</span> var names = &#123;&#125;; <span class="regexp">//</span> 这样会创建一个 Map ，而不是 Set 。</span><br></pre></td></tr></table></figure>

<p><strong>是 Set 还是 Map ？</strong> Map 字面量语法同 Set 字面量语法非常相似。 因为先有的 Map 字母量语法，所以 <code>&#123;&#125;</code> 默认是 <code>Map</code> 类型。   如果忘记在 <code>&#123;&#125;</code> 上注释类型或赋值到一个未声明类型的变量上，   那么 Dart 会创建一个类型为 <code>Map&lt;dynamic, dynamic&gt;</code> 的对象。</p>
<p>使用 <code>add()</code> 或 <code>addAll()</code> 为已有的 Set 添加元素：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> elements = &lt;String&gt;&#123;&#125;;</span><br><span class="line">elements.<span class="keyword">add</span>(<span class="string">&#x27;fluorine&#x27;</span>);</span><br><span class="line">elements.addAll(halogens);</span><br></pre></td></tr></table></figure>

<p>使用 <code>.length</code> 来获取 Set 中元素的个数：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">var elements = &lt;String&gt;&#123;&#125;;</span><br><span class="line">elements.<span class="builtin-name">add</span>(<span class="string">&#x27;fluorine&#x27;</span>);</span><br><span class="line">elements.addAll(halogens);</span><br><span class="line"><span class="builtin-name">print</span>(elements.length == 5);</span><br></pre></td></tr></table></figure>

<p>在 Set 字面量前增加 <code>const</code> ，来创建一个编译时 Set 常量：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">final constantSet = const &#123;</span><br><span class="line">  <span class="string">&#x27;fluorine&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;chlorine&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;bromine&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;iodine&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;astatine&#x27;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="regexp">//</span> constantSet.add(<span class="string">&#x27;helium&#x27;</span>); <span class="regexp">//</span> Uncommenting this causes an error.</span><br></pre></td></tr></table></figure>

<p>更多关于 Set 的内容，参阅 <a href="https://www.dartcn.com/guides/language/language-tour#generics">Generic</a> 及 <a href="https://www.dartcn.com/guides/libraries/library-tour#sets">Set</a>。</p>
<h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><p>通常来说， Map 是用来关联 keys 和 values 的对象。 keys 和 values 可以是任何类型的对象。在一个 Map 对象中一个 <em>key</em> 只能出现一次。 但是 <em>value</em> 可以出现多次。 Dart 中 Map 通过 Map 字面量 和 <a href="https://api.dartlang.org/stable/dart-core/Map-class.html">Map</a> 类型来实现。</p>
<p>下面是使用 Map 字面量的两个简单例子：</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">var gifts</span> = &#123;</span><br><span class="line">  // Key:    Value</span><br><span class="line">  <span class="string">&#x27;first&#x27;</span>: <span class="string">&#x27;partridge&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;second&#x27;</span>: <span class="string">&#x27;turtledoves&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;fifth&#x27;</span>: <span class="string">&#x27;golden rings&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="attribute">var nobleGases</span> = &#123;</span><br><span class="line">  2: <span class="string">&#x27;helium&#x27;</span>,</span><br><span class="line">  10: <span class="string">&#x27;neon&#x27;</span>,</span><br><span class="line">  18: <span class="string">&#x27;argon&#x27;</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong> Dart 会将 <code>gifts</code> 的类型推断为 <code>Map&lt;String, String&gt;</code>， <code>nobleGases</code> 的类型推断为 <code>Map&lt;int, String&gt;</code> 。 如果尝试在上面的 map 中添加错误类型，那么分析器或者运行时会引发错误。 有关更多信息，请阅读<a href="https://www.dartcn.com/guides/language/sound-dart#type-inference">类型推断。</a>。</p>
<p>以上 Map 对象也可以使用 Map 构造函数创建：</p>
<figure class="highlight prolog"><table><tr><td class="code"><pre><span class="line">var gifts = <span class="symbol">Map</span>();</span><br><span class="line">gifts[<span class="string">&#x27;first&#x27;</span>] = <span class="string">&#x27;partridge&#x27;</span>;</span><br><span class="line">gifts[<span class="string">&#x27;second&#x27;</span>] = <span class="string">&#x27;turtledoves&#x27;</span>;</span><br><span class="line">gifts[<span class="string">&#x27;fifth&#x27;</span>] = <span class="string">&#x27;golden rings&#x27;</span>;</span><br><span class="line"></span><br><span class="line">var nobleGases = <span class="symbol">Map</span>();</span><br><span class="line">nobleGases[<span class="number">2</span>] = <span class="string">&#x27;helium&#x27;</span>;</span><br><span class="line">nobleGases[<span class="number">10</span>] = <span class="string">&#x27;neon&#x27;</span>;</span><br><span class="line">nobleGases[<span class="number">18</span>] = <span class="string">&#x27;argon&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><strong>提示:</strong> 这里为什么只有 <code>Map()</code> ，而不是使用 <code>new Map()</code>。 因为在 Dart 2 中，<code>new</code> 关键字是可选的。 有关更多信息，参考 <a href="https://www.dartcn.com/guides/language/language-tour#%E4%BD%BF%E7%94%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0">构造函数的使用</a>。</p>
<p>类似 JavaScript ，添加 key-value 对到已有的 Map 中：</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> gifts = &#123;<span class="string">&#x27;first&#x27;</span>: <span class="string">&#x27;partridge&#x27;</span>&#125;;</span><br><span class="line">gifts[<span class="string">&#x27;fourth&#x27;</span>] = <span class="string">&#x27;calling birds&#x27;</span>; <span class="comment">// Add a key-value pair</span></span><br></pre></td></tr></table></figure>

<p>类似 JavaScript ，从一个 Map 中获取一个 value：</p>
<figure class="highlight axapta"><table><tr><td class="code"><pre><span class="line"><span class="built_in">var</span> gifts = &#123;<span class="string">&#x27;first&#x27;</span>: <span class="string">&#x27;partridge&#x27;</span>&#125;;</span><br><span class="line"><span class="keyword">print</span>(gifts[<span class="string">&#x27;first&#x27;</span>] == <span class="string">&#x27;partridge&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>如果 Map 中不包含所要查找的 key，那么 Map 返回 null：</p>
<figure class="highlight axapta"><table><tr><td class="code"><pre><span class="line"><span class="built_in">var</span> gifts = &#123;<span class="string">&#x27;first&#x27;</span>: <span class="string">&#x27;partridge&#x27;</span>&#125;;</span><br><span class="line"><span class="keyword">print</span>(gifts[<span class="string">&#x27;fifth&#x27;</span>] == <span class="literal">null</span>);</span><br></pre></td></tr></table></figure>

<p>使用 <code>.length</code> 函数获取当前 Map 中的 key-value 对数量：</p>
<figure class="highlight axapta"><table><tr><td class="code"><pre><span class="line"><span class="built_in">var</span> gifts = &#123;<span class="string">&#x27;first&#x27;</span>: <span class="string">&#x27;partridge&#x27;</span>&#125;;</span><br><span class="line">gifts[<span class="string">&#x27;fourth&#x27;</span>] = <span class="string">&#x27;calling birds&#x27;</span>;</span><br><span class="line"><span class="keyword">print</span>(gifts.length == <span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<p>创建 Map 类型运行时常量，要在 Map 字面量前加上关键字 <code>const</code>。</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">final constantMap = const &#123;</span><br><span class="line">  <span class="number">2</span>: <span class="string">&#x27;helium&#x27;</span>,</span><br><span class="line">  <span class="number">10</span>: <span class="string">&#x27;neon&#x27;</span>,</span><br><span class="line">  <span class="number">18</span>: <span class="string">&#x27;argon&#x27;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span> constantMap[<span class="number">2</span>] = <span class="string">&#x27;Helium&#x27;</span>; <span class="regexp">//</span> 取消注释会引起错误。</span><br></pre></td></tr></table></figure>

<p>更名多关于 Map 的内容，参考 <a href="https://www.dartcn.com/guides/language/language-tour#generics">Generics</a> and <a href="https://www.dartcn.com/guides/libraries/library-tour#maps">Maps</a>.</p>
<h3 id="Rune"><a href="#Rune" class="headerlink" title="Rune"></a>Rune</h3><p>在 Dart 中， Rune 用来表示字符串中的 UTF-32 编码字符。</p>
<p>Unicode 定义了一个全球的书写系统编码， 系统中使用的所有字母，数字和符号都对应唯一的数值编码。 由于 Dart 字符串是一系列 UTF-16 编码单元， 因此要在字符串中表示32位 Unicode 值需要特殊语法支持。</p>
<p>表示 Unicode 编码的常用方法是， <code>\uXXXX</code>, 这里 XXXX 是一个4位的16进制数。 例如，心形符号 (♥) 是 <code>\u2665</code>。 对于特殊的非 4 个数值的情况， 把编码值放到大括号中即可。 例如，emoji 的笑脸 (😊) 是 <code>\u&#123;1f600&#125;</code>。</p>
<p><a href="https://api.dartlang.org/stable/dart-core/String-class.html">String</a> 类有一些属性可以获得 rune 数据。 属性 <code>codeUnitAt</code> 和 <code>codeUnit</code> 返回16位编码数据。 属性 <code>runes</code> 获取字符串中的 Rune 。</p>
<p><strong>提示：</strong> 谨慎使用 list 方式操作 Rune 。 这种方法很容易引发崩溃， 具体原因取决于特定的语言，字符集和操作。 有关更多信息，参考 <a href="http://stackoverflow.com/questions/21521729/how-do-i-reverse-a-string-in-dart">How do I reverse a String in Dart?</a> on Stack Overflow.</p>
<h3 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h3><p>一个 Symbol 对象表示 Dart 程序中声明的运算符或者标识符。 你也许永远都不需要使用 Symbol ，但要按名称引用标识符的 API 时， Symbol 就非常有用了。 因为代码压缩后会改变标识符的名称，但不会改变标识符的符号。 通过字面量 Symbol ，也就是标识符前面添加一个 <code>#</code> 号，来获取标识符的 Symbol 。</p>
<figure class="highlight vala"><table><tr><td class="code"><pre><span class="line"><span class="meta">#radix</span></span><br><span class="line"><span class="meta">#bar</span></span><br></pre></td></tr></table></figure>

<p>Symbol 字面量是编译时常量。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Dart</tag>
      </tags>
  </entry>
</search>
